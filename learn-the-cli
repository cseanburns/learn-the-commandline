#!/usr/bin/env bash
#
# Copyright 2022 Sean Burns
#
# Date: 2022-11-25
#
# Author: Sean Burns <sean.csb@gmail.com>
#
# This program is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public
# License as published by the Free Software Foundation,
# either version 3 of the License, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
# PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public
# License along with this program.  If not, see
# <http://www.gnu.org/licenses/>.
#
# A script to practice basic shell commands / utilities

trap quit 1 2 3 6 EXIT

WORKDIR=$(mktemp -d "$HOME/learn-cli-XXXX") || {
	echo "Could not create practice directory" >&2
	exit 1
}

cd "$WORKDIR" && touch new_file.txt || exit 1

quit() {
	echo -e "\n\nThanks for playing and learning.\n"
	exit 0
}

introduction() {
	clear

	cat <<-EOF

	Welcome to Learn the Command Line.

	This program lets you to practice and learn the command line.

	I will present to you a series of commands and tell you
	what each does. Your job is to use this program to learn
	about them and practice using them. Keep using this
	program over and over until using these commands become
	second nature.

	The commands we will cover here include:

	list files and directories.................. ls
	print name of current/working directory..... pwd
	create a new directory...................... mkdir
	remove or delete an empty directory......... rmdir
	change directory............................ cd
	create an empty file........................ touch
	print characters to output.................. echo
	display contents of a text file............. cat
	copy a file or directory.................... cp
	move or rename a file or directory.......... mv
	remove or delete a file or directory........ rm

	Instructions: when asked to run a command, type the
	command and then press the 'Enter' key to run the command.
	If you make a mistake, this program will let you try again.

	To exit this program before completion, press the key
	combo 'Ctrl-c' (that is, the control key plus the 'c' key).
	EOF
}

###### The 'ls' command ######

lsintro() {
	cat <<-EOF

	##### The 'ls' command #####

	Let us get started with the command to list files and directories:

	ls

	EOF

	printf "Try running the 'ls' command now:\n\n"
}

lsexec() {
	while true; do
		read -rp "$ " lsinput
		if [[ "$lsinput" == "ls" ]]; then
			ls
			break
		else
			echo "Try again."
		fi
	done
}

lssummary() {
	cat <<-EOF

	The 'ls' command lists the files and directories in your
	working (or current) directory.
  
	In a graphical user environment, we would say the working directory
	is the folder that you have opened.

	I have taken the liberty of adding a file named 'new_file.txt'
	to this directory, which you saw after running the 'ls' command.
  
	When you log in to a Linux or Unix system, your working
	directory is usually your home directory.
	On many Linux distributions, your home directory is in a
	directory called '/home', but that might differ on
	macOS (a Unix OS) or other Unix-like operating systems.

	EOF
}

###### The 'pwd' command ######

pwdintro() {
	cat <<-EOF

	##### The 'pwd' command #####

	You can always ask for your working directory by using the
	'pwd' command, which stands for 'print working directory'.\n

	Try running the 'pwd' command now:
	
	EOF
}

pwdexec() {
	while true; do
		read -rp "$ " pwdinput
		if [[ "$pwdinput" == "pwd" ]]; then
			pwd
			break
		else
			echo "Try again."
		fi
	done
}

pwdsummary() {
	cat <<-EOF

	The 'pwd' command listed the 'path' of your working directory.

	When you first log in to this system, the default location of your
	working directory is your home directory. Currently, we are
	working in a temporary directory in your home directory. All
	home directories on this system are named after your username
	and are located in the '/home' parent directory. Thus, they
	look like '/home/USER', where USER is your username.

	The output above should show:

	'/home/USER/learn-cli-XXXX'

	where 'USER' is your usernme and 'XXXX' are random letters and numbers.

	EOF
}

###### The 'mkdir' command ######

mkdirintro() {
	cat <<-EOF

	##### The 'mkdir' command #####

	We have learned how to list the current files and
	directories in our working directory using 'ls' and how to
	check which directory we are in using the 'pwd' command.
	We also want the ability to create new directories, which
	are also called folders. We create new directories with
	the 'mkdir' command, which stands for 'make directory'.

	Unlike the 'ls' and the 'pwd' commands above, the 'mkdir'
	command requires an argument or input. The argument is the
	name of the directory that we want to create. For example,
	if we want to create a directory named 'homework' in our
	working directory, then we use the 'mkdir' command with
	the input 'homework' to create that directory.

	Please note that the names of files and directories on
	Linux are case-sensitive. That means that a directory
	called 'homework' is different than a directory called
	'Homework' or a directory called 'HOMEWORK'.

	Try running the 'mkdir' command now to create a directory
	called 'homework':

	mkdir homework

	EOF
}

mkdirexec() {
	while true; do
		read -rp "$ " mkdirinput
		if [[ "$mkdirinput" == "mkdir homework" ]] ; then
			mkdir homework
			break
		else
			echo "Try again."
		fi
	done
}

mkdirsummary() {
	cat <<-EOF

	The 'mkdir' command created a new directory called 'homework'
	in your working directory. If your working directory is your
	home directory, then the location of the new 'homework'
	directory is '/home/USER/homework'.

	But we are working in a temporary directory in our home directory.
	We can check what directory we are with the 'pwd' command and,
	using the 'ls' command, we can confirm the 'homework' directory
	was created.

	Try the 'pwd' command first to confirm your working directory:

	EOF

	pwdexec

	cat <<-EOF

	Now try the 'ls' command to confirm that the directory
	called 'homework' is listed:

	EOF

	lsexec

	cat <<-EOF

	Very good! So far you have learned how to use three
	commands: 'ls', 'pwd', and 'mkdir'.

	You can create other directories with other names just by
	using different arguments or input for the 'mkdir'
	command.

	In addition to the case-sensitive issue, files and
	documents should not contain special characters, like
	spaces or those characters listed on your keyboard above
	your numbers. Names of files and folders should be one
	string of text. If they include multiple words, then
	separate the words with a dash, an underscore, or use
	camel casing, like so: my-files, my_files, or myFiles.

	EOF
}

###### The 'cd' command ######

cdintro() {
	cat <<-EOF

	##### The 'cd' command #####

	The 'cd' command allows us to change to a different
	directory. Unlike the 'mkdir' command, it does not require
	an argument or input, but we often add input to specify
	which directory we would like to go into (or which folder
	we would like to open). The 'cd' command stands for
	'change directory'.

	Try running the 'cd' command now to change into the new
	'homework' directory:

	cd homework

	EOF
}

cdexec() {
	while true; do
		read -rp "$ " cpinput
		if [[ "$cpinput" == "cd homework" ]]; then
			cd homework || exit 1
			break
		else
			echo "Try again."
		fi
	done
}

cdhomework() {
	cat <<-EOF

	The 'cd' command opened your new 'homework' directory. If
	you use the 'pwd' command, you will see that your location
	has changed to '/home/USER/learn-cli-XXXX/homework'.

	Try that now:

	EOF

	(cd "$WORKDIR"/homework && pwdexec)
}

cdhome() {
	cat <<-EOF

	We can use the 'cd' command without an argument or input to
	take us to our home directory.
  
	That is, if you type 'cd' by itself, it'll take you '/home/USER'.

	However, since we are working in a temporary directory, when we
	type the 'cd' command, it'll take us to that base directory.
	Normally, 'cd' takes us HOME!

	Try typing 'cd' by itself now:

	EOF

	while true; do
		read -rp "$ " cdhome
		if [[ "$cdhome" == "cd" ]]; then
			cd "$WORKDIR" || exit 1
			break
		else
			echo "Try again."
		fi
	done

	cat <<-EOF

	Again, use the 'pwd' command to confirm that you are in
	your home directory, which for the sake of this exercise
	is '/home/USER/learn-cli-XXXX':

	EOF

	pwdexec
}

cdsummary() {
	cat <<-EOF

	Very good! Now you have learned four commands:
	'ls', 'pwd', 'mkdir', and 'cd'.

	The 'cd' command with an argument or input changed your
	working directory to the one specified in the argument or
	input (if that directory exists). Without an argument or
	input, the 'cd' command by itself returned you to your
	home directory, which is /home/USER. We confirmed that
	above with the 'pwd' command.

	EOF
}

###### The 'rmdir' command ######

rmdirintro() {
	cat <<-EOF

	##### The 'rmdir' command #####

	In the prior section, you learned how to create a new
	directory called 'homework'. To remove that directory, we
	use the 'rmdir' command. The 'rmdir' command will only
	remove empty directories. If a directory has other
	directories or files in it, then we will have to use
	another command. More on that later.

	Like the 'mkdir' command, the 'rmdir' command requires an
	argument or input. The argument is the name of the
	directory that we want to remove. For example, if we want
	to remove the empty directory named 'homework' in our
	working directory, then we use the 'rmdir' command like so:

	rmdir homework 

	Try running the 'rmdir' command now to remove the directory
	called 'homework':

	EOF
}

rmdirexec() {
	while true; do
		read -rp "$ " rmdirinput
		if [[ "$rmdirinput" == "rmdir homework" ]]; then
			rmdir homework
			break
		else
			echo "Try again."
		fi
	done
}

rmdirsummary() {
	cat <<-EOF

	The 'rmdir' command removed the empty directory called
	'homework' in your working directory. We can check that
	with the 'ls' command.

	Try the 'ls' command to confirm that the directory called
	'homework' is no longer listed:

	EOF

	lsexec

	cat <<-EOF

	Very good! Now you have learned five commands:
	'ls', 'pwd', 'mkdir', 'cd', and 'rmdir'.\n\n"

	EOF
}

###### The 'touch' command ######

touchintro() {
	cat <<-EOF

	##### The 'touch' command #####

	The 'touch' command is technically used to change a file's
	access and modification timestamp. However, it has this
	nice side effect of creating a new, empty file when its
	input is a new file name. The following 'touch' command
	with 'data.csv' as an argument creates an empty file
	called 'data.csv'.

	touch data.csv

	Try running the above 'touch' command now:

	EOF
}

touchexec() {
	while true; do
		read -rp "$ " touchinput
		if [[ "$touchinput" == "touch data.csv" ]]; then
			touch data.csv

			cat <<-EOF

			Now use the 'ls' command to check that the file now exists.

			EOF
			
			lsexec
			break
		else
			echo "Try again."
		fi
	done
}

touchsummary() {
	cat <<-EOF

	Very good! Now you have learned six commands:
	'ls', 'pwd', 'mkdir', 'cd', 'rmdir', and 'touch'.

	The 'touch' command can be used to create new empty files.
	This command is useful in certain scripting scenarios.

	EOF
}

###### The 'echo' command ######

echointro() {
	cat <<-EOF

	##### The 'echo' command #####

	The 'echo' command displays a line of text, or prints text
	to standard output. It's a simple command and is useful in
	a variety of contexts. To display the line 'hello world', we
	use the 'echo' command like this:

	echo hello world

	Try running the above 'echo' command now:

	EOF
}

echoexec() {
	while true; do
		read -rp "$ " echoinput
		if [[ "$echoinput" == "echo hello world" ]]; then
			echo "hello world"
			break
		else
			echo "Try again."
		fi
	done
}

echoredirectinfo() {
	cat <<-EOF

	The 'echo' command prints to standard output, which by
	default is your screen. However, we can use 'redirection'
	to send the output to a file, like the 'data.csv' file we
	created earlier with the 'touch' command. The redirect
	command is the angle bracket '>'. To print input to the
	file 'data.csv', we use the 'echo' like so, now placing
	double quotes around the text we want to send to the file:

	echo "hello world" > data.csv

	Now you try it:
	
	EOF
}

echoredirect() {
	while true; do
		read -rp "$ " echofile
		if [[ "$echofile" == "echo \"hello world\" > data.csv" ]]; then
			echo "hello world" > data.csv
			break
		else
			echo "Try again."
		fi
	done
}

echosummary() {
	cat <<-EOF

	Very good! Now you have learned seven commands:
	'ls', 'pwd', 'mkdir', 'cd', 'rmdir', 'touch', and 'echo'.

	The 'echo' command can be used to create text. It is
	useful in scripts to report the status of some command.
	Using the redirect command '>', output can be sent to a file.

	EOF
}

###### The 'cat' command' ######

catintro() {
	cat <<-EOF

	##### The 'cat' command #####

	The 'cat' command performs a couple of useful functions.
	Specifically, it 1) displays the contents of a file, and
	2) concatenates (joins) multiple files. Like the 'mkdir', 'rmdir',
	'echo', and other commands, the 'cat' command requires an
	argument or input. The input is usually at least one file
	name. If the input is more than one file name, the 'cat'
	command will display the contents of all the files. With
	redirection, the 'cat' command can be used to redirect the
	output of multiple files into a new file, thereby
	appending, or 'concatenating', files together.

	For example, to 'cat' a single file, the command is:

	cat data.csv

	Try running the above 'cat' command now:

	EOF
}

catexec() {
	while true; do
		read -rp "$ " catinput
		if [[ "$catinput" == "cat data.csv" ]]; then
			cat data.csv
			break
		else
			echo "Try again."
		fi
	done
}

catsummary() {
	cat <<-EOF

	The 'cat' command displayed the content of the 'data.csv' file.

	We could also use redirection, like we did with the 'echo' command,
	to redirect the output of multiple files into a single file.
	For example, the command:

	cat file1.txt file2.txt > file3.txt

	would output the contents of file1.txt and file2.txt into
	file3.txt. If file3.txt did not exist, it would be created.

	Very good! Now you have learned eight commands:
	'ls', 'pwd', 'mkdir', 'cd', 'rmdir', 'touch', 'echo', and 'cat'.

	EOF
}

###### The 'cp' command ######

cpintro() {
	cat <<-EOF

	##### The 'cp' command #####

	The 'cp' command copies files and directories. It
	generally takes two arguments, or two inputs: the name of
	the file or directory to copy and the name of the copy.
	For example, to copy the 'data.csv' file to a file named
	'data.csv.bak', the command is:

	cp data.csv data.csv.bak

	Thus, the first argument is the name of the original file
	and the second argument is the name of the copy.

	Now try the above 'cp' command:

	EOF
}

cpexec() {
	while true; do
		read -rp "$ " cpinput
		if [[ "$cpinput" == "cp data.csv data.csv.bak" ]]; then
			cp data.csv data.csv.bak
			break
		else
			echo "Try again."
		fi
	done
}

cpsummary() {
	cat <<-EOF

	You can check if the copy was successful with the 'ls'
	command. Give it a try:

	EOF

	lsexec

	cat <<-EOF

	Very good! Now you have learned nine commands:
	'ls', 'pwd', 'mkdir', 'cd', 'rmdir', 'touch', 'echo', 'cat', and 'cp'.

	Note that the new copy can be used to rename the file
	while keeping the original file in place. There is also a
	command that will rename or move a file. We cover that next.

	EOF
}

###### The 'mv' command ######

mvintro() {
	cat <<-EOF

	##### The 'mv' command #####

	The 'mv' command moves files and directories. Moving is
	another way of renaming files or directories. Like the
	'cp' command, it generally takes two arguments, or two
	inputs: the name of the file or directory to move or
	rename and the new name or location of the file. Unlike
	the 'cp' command, the original file will no longer exist.
	The renamed file will take its place. For example, to move
	or rename the 'data.csv' file to a file named 'data.old',
	the command is:

	mv data.csv data.old

	Thus, the first argument is the name of the original file
	and the second argument is the new name of the same file.

	Now try the above command:

	EOF
}

mvexec() {
	while true; do
		read -rp "$ " mvinput
		if [[ "$mvinput" == "mv data.csv data.old" ]]; then
			mv data.csv data.old
			break
		else
			echo "Try again."
		fi
	done
}

mvsummary() {
	cat <<-EOF

	You can check if the 'mv' command worked with the 'ls'
	command. Give it a try:

	EOF

	lsexec

	cat <<-EOF

	Very good! Now you have learned ten commands:
	'ls', 'pwd', 'mkdir', 'cd', 'rmdir', 'touch', 'echo', 'cat', 'cp', and 'mv'.

	Unlike the 'cp' command, the 'mv' command does not keep a
	copy of the original file.
	
	EOF
}

###### The 'rm' command ######

rmintro() {
	cat <<-EOF

	##### The 'rm' command #####

	The 'rm' command, short for remove, deletes files and
	directories. You will remember that the 'rmdir' command
	deletes empty directories. We need the 'rm' command to
	delete directories that contain files and sub-directories.
	The 'rm' command does not provide a trash bin for
	recovering deleted files. Once something is deleted with
	'rm', consider it gone for good.

	The 'rm' command also takes arguments or input. It can
	even take multiple arguments. Try running the 'rm' command
	to delete the data.csv.bak and the data.old files we just
	created:

	rm data.csv.bak data.old

	EOF
}

rmexec() {
	while true; do
		read -rp "$ " rminput
		if [[ "$rminput" == "rm data.csv.bak data.old" ]]; then
			rm data.csv.bak data.old
			break
		else
			echo "Try again."
		fi
	done
}

rmsummary() {
	cat <<-EOF

	You can check if the 'rm' command worked with the 'ls'
	command. Give it a try:

	EOF

	lsexec

	cat <<-EOF

	Remember, you should assume that the 'rm' command
	permanently deletes files and directories.

	EOF
}

conclusion() {
	sleep 1

	cat <<-EOF

	Well done!

	You have completed this lesson in learning the
	command line. The eleven commands that you learned include:

	list files and directories.................. ls
	print name of current/working directory..... pwd
	create a new directory...................... mkdir
	remove or delete an empty directory......... rmdir
	change directory............................ cd
	create an empty file........................ touch
	print characters to output.................. echo
	display contents of a text file............. cat
	copy a file or directory.................... cp
	move or rename a file or directory.......... mv
	remove or delete a file or directory........ rm\n

	Each of the above commands have functionality that can be
	extended with the use of 'options'. Options are generally
	composed of a dash and a single letter representing the
	option's function. For example, the 'rm' command includes
	the option '-r', which stands for 'recursive'. We use the
	'-r' option to delete directories with content, like so:

	rm -r a_directory

	EOF

	read -rp "Press Enter to continue"
	clear

	cat <<-EOF

	All of the above commands have a how-to manual. Some of
	these manuals are quite extensive, but they all offer
	instructions in how to use the commands. Except for the
	'cd' command, to read the manual pages for the commands,
	type 'man' and the name of the command. For example, to
	read the manual for the 'cp' command, type:

	man cp

	Use the arrow keys on your keyboard to scroll through the
	manual pages. Press the letter 'q' to exit the manual pages.

	The 'cd' command is a special builtin command. That is,
	it's part of the Bash shell. To read the manual for the
	'cd' command, type:

	help cd

	There are more commands to learn, but once you have practiced
	these, the rest will come easy.

	Run this program over and over again until you get the
	hang of what the commands do and have acquired a good
	understanding of them.

	Until next time!
	
	EOF
}

proceed() {
	read -rp "Press Enter to continue."
	clear
}

cleanup() {
	rm -rf -- "$WORKDIR"
}

trap cleanup EXIT

main() {
	introduction

	proceed

	lsintro
	lsexec
	lssummary

	proceed

	pwdintro
	pwdexec
	pwdsummary

	proceed

	mkdirintro
	mkdirexec
	mkdirsummary

	proceed

	cdintro
	cdexec
	cdhomework
	cdhome
	cdsummary

	proceed

	rmdirintro
	rmdirexec
	rmdirsummary

	proceed

	touchintro
	touchexec
	touchsummary

	proceed

	echointro
	echoexec
	echoredirectinfo
	echoredirect
	echosummary

	proceed

	catintro
	catexec
	catsummary

	proceed

	cpintro
	cpexec
	cpsummary

	proceed

	mvintro
	mvexec
	mvsummary

	proceed

	rmintro
	rmexec
	rmsummary

	proceed

	conclusion
}

main
